from kdnode import kdnode;
from quickselect import select;
import matplotlib.pyplot as plt;
from matplotlib.patches import Rectangle;
import time;
import numpy;

class kdtree:
	def __init__(self, binsize, e):
		self.root = 0;
		self.pts = 0;
		self.maxbinsz = binsize;
		self.emax = e;
	
	def maxRangeDim(self, points, start, end):
		dims = len(points[0]);
		mins = [];
		rnge = [];
		for d in range(dims):
			mins.append( points[start][d] );
			rnge.append(0);
			
		for p in range(start, end):
			for d in range(dims):
				if (points[p][d] > rnge[d]):
					rnge[d] = points[p][d]; # range holds maxs
				if (points[p][d] < mins[d]):
					mins[d] = points[p][d]; # min holds mins
		maxd = 0; # find the dimension with the biggest range
		for d in range(dims):
			rnge[d] -= mins[d];
			if (rnge[d] > rnge[maxd]):
				maxd = d;
		return maxd;
	
	def partition(self, points, start, end, cutdim, minx, miny, maxx, maxy):
		n = kdnode();
		n.st = start;
		n.end = end;
		if ( cutdim >= len(points[0]) ):
			cutdim = 0;
		if ( (end-start) > self.maxbinsz ):
			med = select(points, int( (start+end)/2 )-start, cutdim, start, end-1);
			n.dim = cutdim;
			n.val = med;
			## Plotting ##
			s = [minx, miny];
			e = [maxx, maxy];
			s[n.dim] = n.val[n.dim];
			e[n.dim] = n.val[n.dim];
			plt.plot([s[0], e[0]], [s[1], e[1]]);
			#self.currentAxis.add_patch( Rectangle( (minx, miny), (maxx-minx), (maxy-miny), alpha=0.3, color=numpy.random.rand(3,1) ) );
			self.fig.canvas.draw();
			self.fig.canvas.flush_events();
			plt.show();
			time.sleep(0.5);
			## -------- ##
			mid = int( (start+end)/2 );
			if (cutdim == 0):
				n.lessChild = self.partition(points, start, mid, cutdim+1, minx, miny, e[0], maxy);
				n.greaterChild = self.partition(points, mid, end, cutdim+1, s[0], miny, maxx, maxy);
			elif (cutdim == 1):
				n.lessChild = self.partition(points, start, mid, cutdim+1, minx, miny, maxx, e[1]);
				n.greaterChild = self.partition(points, mid, end, cutdim+1, minx, s[1], maxx, maxy);
		return n;
	
	def makeTree(self, points, minx, miny, maxx, maxy):
		## Plotting ##
		plt.ion();
		self.fig, self.ax = plt.subplots();
		#self.currentAxis = plt.gca();
		self.ax.set_xlim((-0.2, 1.2))
		self.ax.set_ylim((-0.2, 1.2))
		xs, ys = zip(*points);
		plt.scatter(xs, ys);
		## -------- ##
		cutdim = self.maxRangeDim( points, 0, len(points) );
		self.root = self.partition( points, 0, len(points), cutdim, minx, miny, maxx, maxy );
		self.pts = points;
		return self.root;


def queuryNNwrap(queury, n):
	return queuryNN(queury, n, self.root);


def queuryNN(queury, n, root):
	distances = [];
	NNs = [];
	for i in range(n):
	{
		distances.append(9999999999); # nearest neighbor distances initialized to infinity
		NNs.append(-1); # nearest neighbor indices initialized to -1
	}
	std::priority_queue<Node*, std::vector<Node*>, Compare> ordering;
	
	// search KD tree for node with queury point, (lg(total points)*lg(lg(total points)) TC)
	while (root->dim != -1)
	{
		int d = root->dim;
		if (queury[d] < root->val)
		{
			root->greaterChild->dist = abs(root->val - queury[d]);
			//(lg(lg(total points)))
			ordering.push(root->greaterChild);
			root = root->lessChild;
		}
		else
		{
			root->lessChild->dist = abs(root->val - queury[d]);
			//(lg(lg(total points)))
			ordering.push(root->lessChild);
			root = root->greaterChild;
		}
	}
	ordering.push(root);
	int count = 0;
	// search each bin for the nearest neighbor as long as the distance to that bin is less then the distance from the furthest neighbor found so far, ( TC (max bins to search)*(max points per bin)*lg(lg(total points)) )
	while (!ordering.empty() && count < emax)
	{
		Node* dCur = ordering.top();
		ordering.pop();
		// If the distance is farther away then the furthest neighbor found so far then break
		if (pow(dCur->dist,2) < distances[0])
		{
			//iterate through points in current node
			for (int i = dCur->st; i < dCur->end; i++)
			{
				double dist = sqedEucDist((*pts)[i], queury);
				if (dist < distances[0])
				{
					distances[0] = dist;
					NNs[0] = i;
					int ii = 0;
					//iterate through distances
					while (ii < n-1 && distances[ii] < distances[ii+1])
					{
						distances[ii] = distances[ii+1];
						distances[ii+1] = dist;
						NNs[ii] = NNs[ii+1];
						NNs[ii+1] = i;
						ii++;
					}
				}
			}
		count++;
		}
		else
			break;
	}
	// Write neighbors (in descending order of distance)
	std::cout << "input: row #" << queury.back() << std::endl;
	std::cout << "Nearest neighbors (from furthest to nearest) "<< std::endl;
	for (int i = 0; i < NNs.size(); i++)
	{
		std::cout << "Neighbor: row #" << (*pts)[NNs[i]].back() << " in original file: distance away: " << sqrt(distances[i]) << std::endl;
	}
	std::cout << std::endl;
	return NNs;
}

	
		

